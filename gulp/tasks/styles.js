var gulp = require('gulp'),
postcss = require('gulp-postcss'),
autoprefixer = require('autoprefixer'),
// postcss seems to be organized into modules a little bit like Angular 2+...
cssvars = require('postcss-simple-vars'),
nested = require('postcss-nested'),
cssImport = require('postcss-import');
mixins = require('postcss-mixins'),
hexrgba = require('postcss-hexrgba');

/*
**************************
Features of Preprocessors:
**************************
Like:
- Sass
- Less
- Stylus
- PostCSS (fastest to compile of these above preprocessors, and most recent one,
  the one we'll use here)

Allow:
- Create CSS variables: --> $mainBlue: #2f5572;
                        Then we can use it in the CSS files
- Nested CSS

************
autoprefixer
************

  Takes care of adding vendor specific things
  input:

  .item{
    columns: 300px 2;
  }

  output:
  .item{
    -webkit-columns:300px 2;
    -moz-columns:300px 2;
    columns:300px 2;
  }
***************************  
Some useful info about Gulp
***************************

Gulp resides on 3 key terms:
- gulp.src()    --> location of the input CSS file
- gulp.dest()   --> location of the destination FOLDER where to put the processed file
- pipe()        --> connect one gulp.src() to one gulp.dest() where gulp.dest() takes a folder as destination

**************
postcss-import
**************

'@import' is native feature of CSS but the problem with it is that it makes the browser
download multiple CSS files, instead, we will use gulp and postCSS
so when it sees the '@import', it replaces automatically this line
with the actual content of the file

You can witness this behaviour by looking at the output styles.css file
generated by gulp that contains the code of the imported files

**************
postcss-mixins
**************

A mixin is just a reusable bit of code
(Which means not necessarily something that deals with size...)

*/

gulp.task('styles', function(){
  /*
  We return a value because a gulp.src() is an asynchronous function
  So gulp is aware when the function completes
  */
  
  /*
  We need to tell postcss what to do by specifying an array of features to use:
  We tell it here to use:
  - cssImports
  - mixins
  ...
  The order has its importance

  Indeed, we start by cssImport so the imports are replaced
  with their actual file content
  */  
  return gulp.src('./app/assets/styles/styles.css')
          .pipe(postcss([cssImport, mixins, cssvars, nested, hexrgba, autoprefixer]))
          .on('error', function(errorInfo){
            /*
            Log the info in a more digestable way via the toString() method
            'error' is the name of the event we are interested in
            
            If an error occurs, we gracefully exit the task
            Actually, we are saying to the program by doing this:
            Do as if the 'watch' task ended normally ...
            This way, we don't get any errors that will cause the 'watch' task to break
            and thus browserSync to stop the same way

            At least, if an error occurs, we can print out the error on the console
            */
            console.log(errorInfo.toString());
            this.emit('end');
          })
          .pipe(gulp.dest('./app/temp/styles'));
});
